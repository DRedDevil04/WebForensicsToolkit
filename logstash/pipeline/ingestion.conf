input {
  # --- Apache Access Logs ---
  file {
    path => "/var/log/apache2/access.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "apache_access"
    tags => ["apache", "access"]
  }

  # --- ModSecurity / WAF Logs ---
  file {
    path => "/var/log/waf/audit.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "modsec"
    tags => ["waf", "modsecurity"]
  }

  # --- PHP Upload or Forensic Logs ---
  file {
    path => "/var/log/phpapp/upload.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "upload_log"
    tags => ["php", "upload"]
  }
}

filter {

  # ---------------- Apache Access ----------------
  if [type] == "apache_access" {
    grok {
      match => {
        "message" => "%{COMBINEDAPACHELOG}"
      }
      remove_field => ["message"]
    }
    mutate {
      add_field => {
        "event.source" => "apache_access"
        "event.module" => "webserver"
      }
      rename => {
        "clientip" => "[client][ip]"
        "verb" => "[http][method]"
        "request" => "[url][original]"
        "response" => "[http][response][status_code]"
        "agent" => "[user_agent][original]"
        "referrer" => "[http][referrer]"
      }
    }
    useragent {
      source => "[user_agent][original]"
      target => "[user_agent]"
    }
    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      remove_field => ["timestamp"]
    }
  }


  # ---------------- ModSecurity / WAF ----------------
  if [type] == "modsec" {

    # Pre-clean message to remove gzip/binary artifacts
    mutate {
      gsub => [
        "message", "\\\\u001F.*", ""   # remove \u001F and following binary trash
      ]
    }

    # Ruby: extract attack type and timestamp
    ruby {
      code => '
        msg = event.get("message")
        if msg.nil? || msg.empty?
          event.set("attack_type", "Other")
        else
          text = msg.to_s.downcase
          attack = "Other"

          if text.include?("sql")
            attack = "SQL Injection"
          elsif text.include?("xss")
            attack = "XSS"
          elsif text.include?("command execution") || text.include?("cmd=") || text.include?("exec=") || text.include?("system=") || text.include?("shell=")
            attack = "RCE"
          end

          event.set("attack_type", attack)

          # Extract timestamp from message if present
          if text =~ /"time_stamp"\s*:\s*"([^"]+)"/
            ts = $1
            event.set("log_timestamp", ts)
          end
        end

        # Set event metadata
        event.set("event.source", "modsecurity")
        event.set("event.module", "waf")
        event.set("event.category", "web")
      '
    }

    # Convert extracted log_timestamp to @timestamp
    if [log_timestamp] {
      date {
        match => ["log_timestamp", "EEE MMM dd HH:mm:ss yyyy"]
        target => "@timestamp"
        remove_field => ["log_timestamp"]
      }
    }

  }




  # ---------------- PHP Upload / Forensic ----------------
  if [type] == "upload_log" {
    # Example: [2025-11-12T21:01:23Z] [edce9617eb639339] Upload from 172.19.0.1 - filename=test.php size=128KB status=success
    grok {
      match => {
        "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] \[%{DATA:session_id}\] Upload from %{IP:client.ip} - filename=%{DATA:file.name} size=%{DATA:file.size} status=%{WORD:upload.status}"
      }
      tag_on_failure => ["_upload_grok_fail"]
    }
    mutate {
      add_field => {
        "event.source" => "php_upload"
        "event.module" => "application"
        "event.action" => "file_upload"
      }
    }
    date {
      match => [ "timestamp", "ISO8601" ]
      remove_field => ["timestamp"]
    }
  }

  # ---------------- Common Normalization ----------------
  mutate {
    add_field => { "ingested_at" => "%{@timestamp}" }
  }

  # Clean nulls, whitespace, etc.
  mutate {
    strip => ["message"]
    remove_field => ["host", "path", "type"]
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "forensic-logs-%{+YYYY.MM.dd}"
    ilm_enabled => false
  }

  stdout {
    codec => rubydebug
  }
}
